// Command hennacodegen parses hennaList.xml and generates Go literal code
// for the data package (henna_data_generated.go).
//
// Usage: go run ./cmd/hennacodegen -xml path/to/hennaList.xml -out internal/data/henna_data_generated.go
package main

import (
	"encoding/xml"
	"flag"
	"fmt"
	"os"
	"sort"
	"strings"
)

type hennaListXML struct {
	Hennas []hennaXML `xml:"henna"`
}

type hennaXML struct {
	DyeID     int32    `xml:"dyeId,attr"`
	DyeName   string   `xml:"dyeName,attr"`
	DyeItemID int32    `xml:"dyeItemId,attr"`
	Stats     statsXML `xml:"stats"`
	Wear      wearXML  `xml:"wear"`
	Cancel    cancelXML `xml:"cancel"`
	ClassIDs  []int32  `xml:"classId"`
}

type statsXML struct {
	STR int32 `xml:"str,attr"`
	CON int32 `xml:"con,attr"`
	DEX int32 `xml:"dex,attr"`
	INT int32 `xml:"int,attr"`
	MEN int32 `xml:"men,attr"`
	WIT int32 `xml:"wit,attr"`
}

type wearXML struct {
	Count int32 `xml:"count,attr"`
	Fee   int64 `xml:"fee,attr"`
}

type cancelXML struct {
	Count int32 `xml:"count,attr"`
	Fee   int64 `xml:"fee,attr"`
}

func main() {
	xmlPath := flag.String("xml", "", "path to hennaList.xml")
	outPath := flag.String("out", "", "output Go file path")
	flag.Parse()

	if *xmlPath == "" || *outPath == "" {
		fmt.Fprintln(os.Stderr, "usage: hennacodegen -xml <path> -out <path>")
		os.Exit(1)
	}

	data, err := os.ReadFile(*xmlPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "read XML: %v\n", err)
		os.Exit(1)
	}

	var list hennaListXML
	if err := xml.Unmarshal(data, &list); err != nil {
		fmt.Fprintf(os.Stderr, "parse XML: %v\n", err)
		os.Exit(1)
	}

	// Sort by dyeId for deterministic output
	sort.Slice(list.Hennas, func(i, j int) bool {
		return list.Hennas[i].DyeID < list.Hennas[j].DyeID
	})

	var b strings.Builder
	b.WriteString("// Code generated by cmd/hennacodegen; DO NOT EDIT.\n\n")
	b.WriteString("package data\n\n")
	b.WriteString(fmt.Sprintf("// hennaDefs contains %d henna definitions from hennaList.xml.\n", len(list.Hennas)))
	b.WriteString("var hennaDefs = []hennaDef{\n")

	for _, h := range list.Hennas {
		b.WriteString(fmt.Sprintf("\t{dyeID: %d, dyeName: %q, dyeItemID: %d, "+
			"statSTR: %d, statCON: %d, statDEX: %d, statINT: %d, statMEN: %d, statWIT: %d, "+
			"wearCount: %d, wearFee: %d, cancelCount: %d, cancelFee: %d, "+
			"classIDs: []int32{%s}},\n",
			h.DyeID, h.DyeName, h.DyeItemID,
			h.Stats.STR, h.Stats.CON, h.Stats.DEX, h.Stats.INT, h.Stats.MEN, h.Stats.WIT,
			h.Wear.Count, h.Wear.Fee, h.Cancel.Count, h.Cancel.Fee,
			formatClassIDs(h.ClassIDs)))
	}

	b.WriteString("}\n")

	if err := os.WriteFile(*outPath, []byte(b.String()), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "write output: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("generated %d henna definitions â†’ %s\n", len(list.Hennas), *outPath)
}

func formatClassIDs(ids []int32) string {
	parts := make([]string, len(ids))
	for i, id := range ids {
		parts[i] = fmt.Sprintf("%d", id)
	}
	return strings.Join(parts, ", ")
}
